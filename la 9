package marcosRodriguez;

public class Comision {

	String materia;
	int numero;
	Docente [] docentes;
	Estudiante [] inscriptos;
	int [] calificaciones;
	
	public boolean estaEstudiante(Estudiante e2) {
		for (Estudiante e:this.inscriptos) {
			if (e.equals(e2)) {
				return true;
			}
		}
		return false;
	}

	public boolean estaDocente (Docente d2) {
		for (Docente d:this.docentes) {
			if (d.equals(d2)) {
				return true;
			}
		}
		return false;
	}
	
	public int laMejorNota() {
		
		int mejorNota = 0;
		for (int i = 1; i < this.calificaciones.length; i++) {
	        if (this.calificaciones[i] > mejorNota) {
	            mejorNota = this.calificaciones[i];
	        }
	    }

	    return mejorNota;
	}

	
	public int alumnosConMejorNota() {
		int cantAlum = 0;
		for (int i = 0; i < this.inscriptos.length; i++) {
			if(this.calificaciones[i] == laMejorNota()) {
				cantAlum ++;
			}
		}
		return cantAlum;
	}

	public void alumnosConMejorNota(int laMejorNota) {
		// TODO Auto-generated method stub
		
	}

}


package marcosRodriguez;

public class UNGS {

	Comision [] comisiones;
	
	boleean cursaCon(Estudiante e, Docente d) {
		for (Comision con:this.comisiones) {
			if(con.estaDocente(d) && con.estaEstudiante(e)) {
				return true;
			}
		}
		return false;
	}
	
	boolean sufivcientesDocentes() {
		for (Comision co:this.comisiones) {
			if (co.inscriptos.length /20 < co.docentes.length) {
				return false;
			}
		}
		return true
	}
	
	//Estudiante elMasEstudioso () {
		//Estudiante
	//}
	
	private int cantidadaprobadas (Estudiante masEst) {
		int cant = 0;
		for (Comision cc:this.comisiones){
			if (cc.inscrptos[i].equals(masEst && cc.calificaciones[i] >= 4)) {
				cant++;
			}
		}
		
		return cant;
	}
	public int losMejores() {
		int cantAlum = 0;
		//para cada comision
		for (Comision c:this.comisiones) {
			c.laMejorNota();
			// Cuento los alumnos que obtuvieron mejor nota
			c.alumnosConMejorNota(c.laMejorNota());
			}
		
		return cantAlum;
		}
	
	public int alumnosDe (Docente d) {
		int cant = 0;
		for (Comision c: this.comisiones ) {
			if (c.estaDocente(d)){
				cant += c.inscriptos.length;
			}
		}
		return cant;
	}
	
		

}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


package aerolinea;

public class Aerolinea {
	Vuelo[] vuelos;
	
	int vuelosEn(Tripulante t, String tipoAvion) {
		int cant = 0;
		for (Vuelo v: this.vuelos) {
			if (v.avion.tipo.equals(tipoAvion) && v.estaTripulante(t)) {
				cant++;
			}
		}
			
		return cant;
	}
	
	int antiguedadPromedio(String tipoAvion) {
		int promAnt = 0;
		int cantTrip = 0;
		
		for (Vuelo v: this.vuelos) {
			if (v.avion.tipo.equals(tipoAvion)) {
				promAnt += v.sumaAntiguegad();
				cantTrip ++;
			}
		}
		
		return promAnt / cantTrip;
	}
	
	
	Vuelo elMasInspeccionado (){
		Vuelo masIns = this.vuelos[0];
		int cantMaxInspectores = this.vuelos[0].cantDe("Inspector");
		for (Vuelo v: this.vuelos) {
			if(v.cantDe("Inspector") > cantMaxInspectores) {
				masIns = v;
				cantMaxInspectores = v.cantDe("Inspector");
			}
			
		}
		
		return masIns;
	}
	
	boolean hayVueloSobrecargado() {
		for (Vuelo v: this.vuelos) {
			if (v.estaSobrecargado()) {
				return true;
			}
		}
		
		return false;
	}
	
	Tripulante pilotoDelMes() {
			Tripulante pilotoMes = this.vuelos[0].damePiloto();
			int vuelosConPilotoMes = cantVuelosPiloto(pilotoMes);
			for (Vuelo v: this.vuelos) {
				if(cantVuelosPiloto(v.damePiloto()) > vuelosConPilotoMes) {
					pilotoMes = v.damePiloto();
					vuelosConPilotoMes = cantVuelosPiloto(v.damePiloto());
				}
				
			}
			
			return pilotoMes;
		}

	private int cantVuelosPiloto(Tripulante pilotoMes) {
		int cantVuelos = 0;
		for (Vuelo v: this.vuelos) {
		if (v.damePiloto().equals(pilotoMes)){
			cantVuelos++;
		}
	}
		return cantVuelos
	}
}

package aerolinea;

public class Vuelo {
 Avion avion;
 Tripulante [] tripulacion;
public int sumaAntiguegad() {
	int cant = 0;
	for (Tripulante tr:this.tripulacion) {
		cant += tr.antiguedad;
	}
	
	return cant;
}

public boolean estaTripulante(Tripulante t) {
	for (Tripulante tr:this.tripulacion) {
		if (tr.equals(t)){
			return true;
		}
	}
	return false;
}

public int cantDe(String cargo) {
	int cantInsp = 0;
	for (Tripulante t: this.tripulacion) {
		if(t.cargo.equals(cargo)) {
			cantInsp++;
		}
	}
	return cantInsp;
}

public boolean estaSobrecargado() {
	return cantDe("Aeromozo") >this.avion.capacidad * 0.1;
}

public Tripulante damePiloto() {
	for (Tripulante tr: this.tripulacion) {
		if (tr.cargo.equals("Piloto")) {
			return tr;
		}
	}
	throw new RuntimeException("Vuelo no valido");
}

}


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

COMPLEJIDAD COMPUTACIONAL
Como saber cuando un algoritmo es mejor? Es mejor aquel que resuelva el problema mas rapido. Funciones segun su tipo 
